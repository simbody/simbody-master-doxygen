<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::CloneOnWritePtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1CloneOnWritePtr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1CloneOnWritePtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::CloneOnWritePtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write on the contained object.  
 <a href="classSimTK_1_1CloneOnWritePtr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae9fb350ebcbb65fad672cca52a0dca8e"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ae9fb350ebcbb65fad672cca52a0dca8e">element_type</a></td></tr>
<tr class="memdesc:ae9fb350ebcbb65fad672cca52a0dca8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the contained object.  <a href="#ae9fb350ebcbb65fad672cca52a0dca8e">More...</a><br /></td></tr>
<tr class="separator:ae9fb350ebcbb65fad672cca52a0dca8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4404af2931fb602283504a1b940ede7"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ad4404af2931fb602283504a1b940ede7">pointer</a></td></tr>
<tr class="memdesc:ad4404af2931fb602283504a1b940ede7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the contained object.  <a href="#ad4404af2931fb602283504a1b940ede7">More...</a><br /></td></tr>
<tr class="separator:ad4404af2931fb602283504a1b940ede7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90475a884c336f517698b5ba535c1e38"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a90475a884c336f517698b5ba535c1e38">reference</a></td></tr>
<tr class="memdesc:a90475a884c336f517698b5ba535c1e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a reference to the contained object.  <a href="#a90475a884c336f517698b5ba535c1e38">More...</a><br /></td></tr>
<tr class="separator:a90475a884c336f517698b5ba535c1e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a5c1d3e8500bbde3fe5f126d182ff2427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a5c1d3e8500bbde3fe5f126d182ff2427">CloneOnWritePtr</a> () noexcept</td></tr>
<tr class="memdesc:a5c1d3e8500bbde3fe5f126d182ff2427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor stores a <code>nullptr</code> and sets use count to zero.  <a href="#a5c1d3e8500bbde3fe5f126d182ff2427">More...</a><br /></td></tr>
<tr class="separator:a5c1d3e8500bbde3fe5f126d182ff2427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5adc26a0b4ae8881ca2e742bb325b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9d5adc26a0b4ae8881ca2e742bb325b6">CloneOnWritePtr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a9d5adc26a0b4ae8881ca2e742bb325b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from <code>nullptr</code> is the same as the default constructor.  <a href="#a9d5adc26a0b4ae8881ca2e742bb325b6">More...</a><br /></td></tr>
<tr class="separator:a9d5adc26a0b4ae8881ca2e742bb325b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4221e4123a1aecc3b113b92edec1ddf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a4221e4123a1aecc3b113b92edec1ddf0">CloneOnWritePtr</a> (T *x)</td></tr>
<tr class="memdesc:a4221e4123a1aecc3b113b92edec1ddf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a writable heap-allocated object, take over ownership of that object.  <a href="#a4221e4123a1aecc3b113b92edec1ddf0">More...</a><br /></td></tr>
<tr class="separator:a4221e4123a1aecc3b113b92edec1ddf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2041ef2c93c5d6d98f77cf5b78b32159"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a2041ef2c93c5d6d98f77cf5b78b32159">CloneOnWritePtr</a> (const T *x)</td></tr>
<tr class="memdesc:a2041ef2c93c5d6d98f77cf5b78b32159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a read-only object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this CloneOnWritePtr the owner of the copy.  <a href="#a2041ef2c93c5d6d98f77cf5b78b32159">More...</a><br /></td></tr>
<tr class="separator:a2041ef2c93c5d6d98f77cf5b78b32159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bbe08ef9f75c8b6377a53f418aea0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ab8bbe08ef9f75c8b6377a53f418aea0a">CloneOnWritePtr</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab8bbe08ef9f75c8b6377a53f418aea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a read-only reference to an object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this CloneOnWritePtr object the owner of the copy.  <a href="#ab8bbe08ef9f75c8b6377a53f418aea0a">More...</a><br /></td></tr>
<tr class="separator:ab8bbe08ef9f75c8b6377a53f418aea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed4a7478f61750012ca7bee79364066"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a6ed4a7478f61750012ca7bee79364066">CloneOnWritePtr</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;src) noexcept</td></tr>
<tr class="memdesc:a6ed4a7478f61750012ca7bee79364066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deep but deferred so very fast here; the new CloneOnWritePtr object initially shares the source object, but if either source or destination are written to subsequently a deep copy is made and the objects become disconnected.  <a href="#a6ed4a7478f61750012ca7bee79364066">More...</a><br /></td></tr>
<tr class="separator:a6ed4a7478f61750012ca7bee79364066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b021663c3db1987b0cf420186005a75"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a5b021663c3db1987b0cf420186005a75"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a5b021663c3db1987b0cf420186005a75">CloneOnWritePtr</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;src) noexcept</td></tr>
<tr class="memdesc:a5b021663c3db1987b0cf420186005a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction from a compatible CloneOnWritePtr.  <a href="#a5b021663c3db1987b0cf420186005a75">More...</a><br /></td></tr>
<tr class="separator:a5b021663c3db1987b0cf420186005a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e07209a38f4568bafe441571045e93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a59e07209a38f4568bafe441571045e93">CloneOnWritePtr</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a59e07209a38f4568bafe441571045e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor is very fast and leaves the source empty.  <a href="#a59e07209a38f4568bafe441571045e93">More...</a><br /></td></tr>
<tr class="separator:a59e07209a38f4568bafe441571045e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843dabc66a52516f96612fa7c32631c2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a843dabc66a52516f96612fa7c32631c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a843dabc66a52516f96612fa7c32631c2">CloneOnWritePtr</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a843dabc66a52516f96612fa7c32631c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction from a compatible CloneOnWritePtr.  <a href="#a843dabc66a52516f96612fa7c32631c2">More...</a><br /></td></tr>
<tr class="separator:a843dabc66a52516f96612fa7c32631c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:ac1bce165ed3148676370306553fdaf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac1bce165ed3148676370306553fdaf08">operator=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;src) noexcept</td></tr>
<tr class="memdesc:ac1bce165ed3148676370306553fdaf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment replaces the currently-held object by a deferred copy of the object held in the source container.  <a href="#ac1bce165ed3148676370306553fdaf08">More...</a><br /></td></tr>
<tr class="separator:ac1bce165ed3148676370306553fdaf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1351ca22a5de6b5921b19add66481d3"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aa1351ca22a5de6b5921b19add66481d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa1351ca22a5de6b5921b19add66481d3">operator=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;src) noexcept</td></tr>
<tr class="memdesc:aa1351ca22a5de6b5921b19add66481d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible CloneOnWritePtr.  <a href="#aa1351ca22a5de6b5921b19add66481d3">More...</a><br /></td></tr>
<tr class="separator:aa1351ca22a5de6b5921b19add66481d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d08078e1b67df2966c43fcfc386b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a19d08078e1b67df2966c43fcfc386b98">operator=</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a19d08078e1b67df2966c43fcfc386b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#a19d08078e1b67df2966c43fcfc386b98">More...</a><br /></td></tr>
<tr class="separator:a19d08078e1b67df2966c43fcfc386b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55ea49da55d36f3442a61b3a566b47"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aba55ea49da55d36f3442a61b3a566b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aba55ea49da55d36f3442a61b3a566b47">operator=</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aba55ea49da55d36f3442a61b3a566b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment from a compatible CloneOnWritePtr.  <a href="#aba55ea49da55d36f3442a61b3a566b47">More...</a><br /></td></tr>
<tr class="separator:aba55ea49da55d36f3442a61b3a566b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00da4ac5c738d5fb0c121482dae13558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a00da4ac5c738d5fb0c121482dae13558">operator=</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a00da4ac5c738d5fb0c121482dae13558"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its <code>clone()</code> method.  <a href="#a00da4ac5c738d5fb0c121482dae13558">More...</a><br /></td></tr>
<tr class="separator:a00da4ac5c738d5fb0c121482dae13558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad1aa921753aa38e5ff89f233cf58eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8ad1aa921753aa38e5ff89f233cf58eb">operator=</a> (T *x) noexcept</td></tr>
<tr class="memdesc:a8ad1aa921753aa38e5ff89f233cf58eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object.  <a href="#a8ad1aa921753aa38e5ff89f233cf58eb">More...</a><br /></td></tr>
<tr class="separator:a8ad1aa921753aa38e5ff89f233cf58eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a8875d31f20908dd5cfcf86815349cede"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8875d31f20908dd5cfcf86815349cede">~CloneOnWritePtr</a> () noexcept</td></tr>
<tr class="memdesc:a8875d31f20908dd5cfcf86815349cede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor decrements the reference count and deletes the object if the count goes to zero.  <a href="#a8875d31f20908dd5cfcf86815349cede">More...</a><br /></td></tr>
<tr class="separator:a8875d31f20908dd5cfcf86815349cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr class="memitem:ac483710f060ce938840765a385b3a025"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac483710f060ce938840765a385b3a025">get</a> () const  noexcept</td></tr>
<tr class="memdesc:ac483710f060ce938840765a385b3a025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the contained object if any, or <code>nullptr</code>.  <a href="#ac483710f060ce938840765a385b3a025">More...</a><br /></td></tr>
<tr class="separator:ac483710f060ce938840765a385b3a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ad53f09e64871aa0952932e312f6d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9a7ad53f09e64871aa0952932e312f6d">upd</a> ()</td></tr>
<tr class="memdesc:a9a7ad53f09e64871aa0952932e312f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone if necessary to ensure the contained object is not shared, then return a writable pointer to the contained (and now unshared) object if any, or <code>nullptr</code>.  <a href="#a9a7ad53f09e64871aa0952932e312f6d">More...</a><br /></td></tr>
<tr class="separator:a9a7ad53f09e64871aa0952932e312f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d26a596811ed59c1e3afbbc6fcc3fcf"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a3d26a596811ed59c1e3afbbc6fcc3fcf">getRef</a> () const </td></tr>
<tr class="memdesc:a3d26a596811ed59c1e3afbbc6fcc3fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the contained object.  <a href="#a3d26a596811ed59c1e3afbbc6fcc3fcf">More...</a><br /></td></tr>
<tr class="separator:a3d26a596811ed59c1e3afbbc6fcc3fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee60840bbcc2525721ebab5be64637"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a2cee60840bbcc2525721ebab5be64637">updRef</a> ()</td></tr>
<tr class="memdesc:a2cee60840bbcc2525721ebab5be64637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone if necessary to ensure the contained object is not shared, then return a writable reference to the contained (and now unshared) object.  <a href="#a2cee60840bbcc2525721ebab5be64637">More...</a><br /></td></tr>
<tr class="separator:a2cee60840bbcc2525721ebab5be64637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7e6bd1181466be2d004bdfb6c7e246"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aee7e6bd1181466be2d004bdfb6c7e246">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:aee7e6bd1181466be2d004bdfb6c7e246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a const pointer to the contained object.  <a href="#aee7e6bd1181466be2d004bdfb6c7e246">More...</a><br /></td></tr>
<tr class="separator:aee7e6bd1181466be2d004bdfb6c7e246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add7338b713f99632059eeebfa1ff8f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a7add7338b713f99632059eeebfa1ff8f">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a7add7338b713f99632059eeebfa1ff8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone if necessary, then dereference a writable pointer to the contained object.  <a href="#a7add7338b713f99632059eeebfa1ff8f">More...</a><br /></td></tr>
<tr class="separator:a7add7338b713f99632059eeebfa1ff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ade6648f901dd62cf1731bfc94d3e47"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0ade6648f901dd62cf1731bfc94d3e47">operator*</a> () const </td></tr>
<tr class="memdesc:a0ade6648f901dd62cf1731bfc94d3e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This "dereference" operator returns a const reference to the contained object.  <a href="#a0ade6648f901dd62cf1731bfc94d3e47">More...</a><br /></td></tr>
<tr class="separator:a0ade6648f901dd62cf1731bfc94d3e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5029f0881198c4694a9323de29c89a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ade5029f0881198c4694a9323de29c89a">operator*</a> ()</td></tr>
<tr class="memdesc:ade5029f0881198c4694a9323de29c89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone if necessary, then return a writable reference to the contained object.  <a href="#ade5029f0881198c4694a9323de29c89a">More...</a><br /></td></tr>
<tr class="separator:ade5029f0881198c4694a9323de29c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Methods</div></td></tr>
<tr class="memitem:a90004b583b297d294caab778510a9837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a90004b583b297d294caab778510a9837">reset</a> () noexcept</td></tr>
<tr class="memdesc:a90004b583b297d294caab778510a9837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this container empty, decrementing the use count of the contained object (if any), and deleting it if this was the last use.  <a href="#a90004b583b297d294caab778510a9837">More...</a><br /></td></tr>
<tr class="separator:a90004b583b297d294caab778510a9837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87ed731f397a14c523b6d14e493db9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ae87ed731f397a14c523b6d14e493db9b">reset</a> (T *x)</td></tr>
<tr class="memdesc:ae87ed731f397a14c523b6d14e493db9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents of this container with the supplied heap-allocated object, taking over ownership of that object and deleting the current one first if necessary.  <a href="#ae87ed731f397a14c523b6d14e493db9b">More...</a><br /></td></tr>
<tr class="separator:ae87ed731f397a14c523b6d14e493db9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6d383f13455024e66f4785b4cfecd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8a6d383f13455024e66f4785b4cfecd5">swap</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a8a6d383f13455024e66f4785b4cfecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this CloneOnWritePtr with another one, with ownership changing hands but no copying performed.  <a href="#a8a6d383f13455024e66f4785b4cfecd5">More...</a><br /></td></tr>
<tr class="separator:a8a6d383f13455024e66f4785b4cfecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d15b6b1bdf7da8fe2c4e17bd2914412"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a4d15b6b1bdf7da8fe2c4e17bd2914412">use_count</a> () const  noexcept</td></tr>
<tr class="memdesc:a4d15b6b1bdf7da8fe2c4e17bd2914412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of how many CloneOnWritePtr objects are currently sharing the referenced object.  <a href="#a4d15b6b1bdf7da8fe2c4e17bd2914412">More...</a><br /></td></tr>
<tr class="separator:a4d15b6b1bdf7da8fe2c4e17bd2914412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b218ae4f68a0785fca9849a9fc12a9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0b218ae4f68a0785fca9849a9fc12a9c">unique</a> () const  noexcept</td></tr>
<tr class="memdesc:a0b218ae4f68a0785fca9849a9fc12a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the only user of the referenced object? Note that this means there is exactly one; if the managed pointer is null <code><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0b218ae4f68a0785fca9849a9fc12a9c" title="Is this the only user of the referenced object? Note that this means there is exactly one; if the man...">unique()</a></code> returns <code>false</code>.  <a href="#a0b218ae4f68a0785fca9849a9fc12a9c">More...</a><br /></td></tr>
<tr class="separator:a0b218ae4f68a0785fca9849a9fc12a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac706c1449db69f76c60f08ecc8dd4421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac706c1449db69f76c60f08ecc8dd4421">empty</a> () const  noexcept</td></tr>
<tr class="memdesc:ac706c1449db69f76c60f08ecc8dd4421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations.  <a href="#ac706c1449db69f76c60f08ecc8dd4421">More...</a><br /></td></tr>
<tr class="separator:ac706c1449db69f76c60f08ecc8dd4421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e3c406a909af3d6f6bff28e80582d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aec4e3c406a909af3d6f6bff28e80582d">operator bool</a> () const  noexcept</td></tr>
<tr class="memdesc:aec4e3c406a909af3d6f6bff28e80582d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a conversion to type bool that returns true if the container is non-null (that is, not empty).  <a href="#aec4e3c406a909af3d6f6bff28e80582d">More...</a><br /></td></tr>
<tr class="separator:aec4e3c406a909af3d6f6bff28e80582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d53f9c80eb6bd7bf5680df5c5938b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a630d53f9c80eb6bd7bf5680df5c5938b">release</a> ()</td></tr>
<tr class="memdesc:a630d53f9c80eb6bd7bf5680df5c5938b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Remove the contained object from management by this container and transfer ownership to the caller.  <a href="#a630d53f9c80eb6bd7bf5680df5c5938b">More...</a><br /></td></tr>
<tr class="separator:a630d53f9c80eb6bd7bf5680df5c5938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ee5e9f80299d50ce0774728f0c0e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa1ee5e9f80299d50ce0774728f0c0e51">detach</a> ()</td></tr>
<tr class="memdesc:aa1ee5e9f80299d50ce0774728f0c0e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Force the contained object to be unique, that is, not shared with any other container.  <a href="#aa1ee5e9f80299d50ce0774728f0c0e51">More...</a><br /></td></tr>
<tr class="separator:aa1ee5e9f80299d50ce0774728f0c0e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1c09465396083cc53e0a51fa85f5595a"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a1c09465396083cc53e0a51fa85f5595a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a1c09465396083cc53e0a51fa85f5595a">CloneOnWritePtr</a></td></tr>
<tr class="separator:a1c09465396083cc53e0a51fa85f5595a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a305886fdde10d9f9d1eac1c13a912bda"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a305886fdde10d9f9d1eac1c13a912bda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a305886fdde10d9f9d1eac1c13a912bda">swap</a> (<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;p1, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:a305886fdde10d9f9d1eac1c13a912bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8a6d383f13455024e66f4785b4cfecd5" title="Swap the contents of this CloneOnWritePtr with another one, with ownership changing hands but no copy...">swap()</a> member of the <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> class.  <a href="#a305886fdde10d9f9d1eac1c13a912bda">More...</a><br /></td></tr>
<tr class="separator:a305886fdde10d9f9d1eac1c13a912bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df0452a96b1da32bb197301e56dc25"><td class="memTemplParams" colspan="2">template&lt;class charT , class traits , class T &gt; </td></tr>
<tr class="memitem:ab4df0452a96b1da32bb197301e56dc25"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ab4df0452a96b1da32bb197301e56dc25">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ab4df0452a96b1da32bb197301e56dc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> object.  <a href="#ab4df0452a96b1da32bb197301e56dc25">More...</a><br /></td></tr>
<tr class="separator:ab4df0452a96b1da32bb197301e56dc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa3df00bd1a5f653caded9d9cbfcc95"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:abaa3df00bd1a5f653caded9d9cbfcc95"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#abaa3df00bd1a5f653caded9d9cbfcc95">operator==</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abaa3df00bd1a5f653caded9d9cbfcc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> containers.  <a href="#abaa3df00bd1a5f653caded9d9cbfcc95">More...</a><br /></td></tr>
<tr class="separator:abaa3df00bd1a5f653caded9d9cbfcc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805edb06386500e30487ee74383a68f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a805edb06386500e30487ee74383a68f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a805edb06386500e30487ee74383a68f4">operator==</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a805edb06386500e30487ee74383a68f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>.  <a href="#a805edb06386500e30487ee74383a68f4">More...</a><br /></td></tr>
<tr class="separator:a805edb06386500e30487ee74383a68f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c84dc6d905d04e8e5fcd863e6ffd7d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a66c84dc6d905d04e8e5fcd863e6ffd7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a66c84dc6d905d04e8e5fcd863e6ffd7d">operator==</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a66c84dc6d905d04e8e5fcd863e6ffd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>.  <a href="#a66c84dc6d905d04e8e5fcd863e6ffd7d">More...</a><br /></td></tr>
<tr class="separator:a66c84dc6d905d04e8e5fcd863e6ffd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24aaa7eddbde21ecd90cd97c9e8231c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab24aaa7eddbde21ecd90cd97c9e8231c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ab24aaa7eddbde21ecd90cd97c9e8231c">operator&lt;</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab24aaa7eddbde21ecd90cd97c9e8231c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for two compatible <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to.  <a href="#ab24aaa7eddbde21ecd90cd97c9e8231c">More...</a><br /></td></tr>
<tr class="separator:ab24aaa7eddbde21ecd90cd97c9e8231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fe65c19e8cee630103f47f170122d1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa6fe65c19e8cee630103f47f170122d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa6fe65c19e8cee630103f47f170122d1">operator&lt;</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:aa6fe65c19e8cee630103f47f170122d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison against a <code>nullptr</code>.  <a href="#aa6fe65c19e8cee630103f47f170122d1">More...</a><br /></td></tr>
<tr class="separator:aa6fe65c19e8cee630103f47f170122d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40af12397c373865361711db33958f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab40af12397c373865361711db33958f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ab40af12397c373865361711db33958f4">operator&lt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab40af12397c373865361711db33958f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison of a <code>nullptr</code> against this container.  <a href="#ab40af12397c373865361711db33958f4">More...</a><br /></td></tr>
<tr class="separator:ab40af12397c373865361711db33958f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4250258c2521cad226082a51bd476c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:abe4250258c2521cad226082a51bd476c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#abe4250258c2521cad226082a51bd476c">operator!=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abe4250258c2521cad226082a51bd476c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer inequality test defined as <code>!(lhs==rhs)</code>.  <a href="#abe4250258c2521cad226082a51bd476c">More...</a><br /></td></tr>
<tr class="separator:abe4250258c2521cad226082a51bd476c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335f404de1522f46b8411885b29374da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a335f404de1522f46b8411885b29374da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a335f404de1522f46b8411885b29374da">operator!=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a335f404de1522f46b8411885b29374da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>.  <a href="#a335f404de1522f46b8411885b29374da">More...</a><br /></td></tr>
<tr class="separator:a335f404de1522f46b8411885b29374da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c31f81e65157147a6149eb64480acd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa9c31f81e65157147a6149eb64480acd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa9c31f81e65157147a6149eb64480acd">operator!=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa9c31f81e65157147a6149eb64480acd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>.  <a href="#aa9c31f81e65157147a6149eb64480acd">More...</a><br /></td></tr>
<tr class="separator:aa9c31f81e65157147a6149eb64480acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc205fb339ea58d05d4edb95e2c4669"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aebc205fb339ea58d05d4edb95e2c4669"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aebc205fb339ea58d05d4edb95e2c4669">operator&gt;</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aebc205fb339ea58d05d4edb95e2c4669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-than test defined as <code>rhs &lt; lhs</code>.  <a href="#aebc205fb339ea58d05d4edb95e2c4669">More...</a><br /></td></tr>
<tr class="separator:aebc205fb339ea58d05d4edb95e2c4669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e9a1b0fbac551dd20748babdd6e45"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af67e9a1b0fbac551dd20748babdd6e45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#af67e9a1b0fbac551dd20748babdd6e45">operator&gt;</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:af67e9a1b0fbac551dd20748babdd6e45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>.  <a href="#af67e9a1b0fbac551dd20748babdd6e45">More...</a><br /></td></tr>
<tr class="separator:af67e9a1b0fbac551dd20748babdd6e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501845be0e9acafefb86dd8032abcc32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a501845be0e9acafefb86dd8032abcc32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a501845be0e9acafefb86dd8032abcc32">operator&gt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a501845be0e9acafefb86dd8032abcc32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>.  <a href="#a501845be0e9acafefb86dd8032abcc32">More...</a><br /></td></tr>
<tr class="separator:a501845be0e9acafefb86dd8032abcc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49164d590f9c65ff017f111afd79cb70"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a49164d590f9c65ff017f111afd79cb70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a49164d590f9c65ff017f111afd79cb70">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a49164d590f9c65ff017f111afd79cb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>.  <a href="#a49164d590f9c65ff017f111afd79cb70">More...</a><br /></td></tr>
<tr class="separator:a49164d590f9c65ff017f111afd79cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4241a2a3e5d2e394e2ca88a4219dd806"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4241a2a3e5d2e394e2ca88a4219dd806"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a4241a2a3e5d2e394e2ca88a4219dd806">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a4241a2a3e5d2e394e2ca88a4219dd806"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>.  <a href="#a4241a2a3e5d2e394e2ca88a4219dd806">More...</a><br /></td></tr>
<tr class="separator:a4241a2a3e5d2e394e2ca88a4219dd806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e55858ff2ca40c0c1b2933144c8bd5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e55858ff2ca40c0c1b2933144c8bd5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a5e55858ff2ca40c0c1b2933144c8bd5d">operator&gt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5e55858ff2ca40c0c1b2933144c8bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>.  <a href="#a5e55858ff2ca40c0c1b2933144c8bd5d">More...</a><br /></td></tr>
<tr class="separator:a5e55858ff2ca40c0c1b2933144c8bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c47ba9794eefaced72b3427d6e04a2d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8c47ba9794eefaced72b3427d6e04a2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8c47ba9794eefaced72b3427d6e04a2d">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8c47ba9794eefaced72b3427d6e04a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments).  <a href="#a8c47ba9794eefaced72b3427d6e04a2d">More...</a><br /></td></tr>
<tr class="separator:a8c47ba9794eefaced72b3427d6e04a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8bc6c2be1f4d9eed83037af1668a1f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0e8bc6c2be1f4d9eed83037af1668a1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0e8bc6c2be1f4d9eed83037af1668a1f">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a0e8bc6c2be1f4d9eed83037af1668a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments).  <a href="#a0e8bc6c2be1f4d9eed83037af1668a1f">More...</a><br /></td></tr>
<tr class="separator:a0e8bc6c2be1f4d9eed83037af1668a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e50ec408ab41fcb328562d729a7e8e8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e50ec408ab41fcb328562d729a7e8e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a7e50ec408ab41fcb328562d729a7e8e8">operator&lt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7e50ec408ab41fcb328562d729a7e8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments).  <a href="#a7e50ec408ab41fcb328562d729a7e8e8">More...</a><br /></td></tr>
<tr class="separator:a7e50ec408ab41fcb328562d729a7e8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SimTK::CloneOnWritePtr&lt; T &gt;</h3>

<p>Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write on the contained object. </p>
<p>This is like <code>std::shared_ptr</code> when an object is being read, but like <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">SimTK::ClonePtr</a> when the object is written. Like <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">SimTK::ClonePtr</a>, CloneOnWritePtr supports copy and assignment operations, by insisting that the contained object have a <code>clone()</code> method that returns a pointer to a heap-allocated deep copy of the <em>concrete</em> object. The API is modeled as closely as possible to the C++11 <code>std::shared_ptr</code> and <code>std::unique_ptr</code>. However, it always uses a default deleter. Also, the <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac483710f060ce938840765a385b3a025" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> method is modified to return a const pointer to avoid accidental copying, with <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9a7ad53f09e64871aa0952932e312f6d" title="Clone if necessary to ensure the contained object is not shared, then return a writable pointer to th...">upd()</a> (update) added to return a writable pointer.</p>
<p>This class is entirely inline and has no computational or space overhead beyond the cost of dealing with the reference count, except when a copy has to be made due to a write attempt.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the contained object, which <em>must</em> have a <code>clone()</code> method. May be an abstract or concrete type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a>, <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae9fb350ebcbb65fad672cca52a0dca8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ae9fb350ebcbb65fad672cca52a0dca8e">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the contained object. </p>

</div>
</div>
<a class="anchor" id="ad4404af2931fb602283504a1b940ede7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ad4404af2931fb602283504a1b940ede7">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a pointer to the contained object. </p>

</div>
</div>
<a class="anchor" id="a90475a884c336f517698b5ba535c1e38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a90475a884c336f517698b5ba535c1e38">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a reference to the contained object. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5c1d3e8500bbde3fe5f126d182ff2427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor stores a <code>nullptr</code> and sets use count to zero. </p>
<p>No heap allocation is performed. The <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac706c1449db69f76c60f08ecc8dd4421" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> method will return true when called on a default-constructed CloneOnWritePtr. </p>

</div>
</div>
<a class="anchor" id="a9d5adc26a0b4ae8881ca2e742bb325b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from <code>nullptr</code> is the same as the default constructor. </p>
<p>This is an implicit conversion that allows <code>nullptr</code> to be used to initialize a CloneOnWritePtr. </p>

</div>
</div>
<a class="anchor" id="a4221e4123a1aecc3b113b92edec1ddf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a writable heap-allocated object, take over ownership of that object. </p>
<p>The use count will be one unless the pointer was null in which case it will be zero. </p>

</div>
</div>
<a class="anchor" id="a2041ef2c93c5d6d98f77cf5b78b32159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a read-only object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this CloneOnWritePtr the owner of the copy. </p>
<p>Ownership of the original object is not affected. If the supplied pointer is null, the resulting CloneOnWritePtr is as though default constructed, otherwise the use count will be one. </p>

</div>
</div>
<a class="anchor" id="ab8bbe08ef9f75c8b6377a53f418aea0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a read-only reference to an object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this CloneOnWritePtr object the owner of the copy. </p>
<p>Ownership of the original object is not affected. The use count will be one after construction. </p>

</div>
</div>
<a class="anchor" id="a6ed4a7478f61750012ca7bee79364066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is deep but deferred so very fast here; the new CloneOnWritePtr object initially shares the source object, but if either source or destination are written to subsequently a deep copy is made and the objects become disconnected. </p>
<p>If the source container is empty this one will be as though default constructed. </p>

</div>
</div>
<a class="anchor" id="a5b021663c3db1987b0cf420186005a75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construction from a compatible CloneOnWritePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. </p>

</div>
</div>
<a class="anchor" id="a59e07209a38f4568bafe441571045e93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor is very fast and leaves the source empty. </p>
<p>The use count is unchanged. If the source was empty this one will be as though default constructed. </p>

</div>
</div>
<a class="anchor" id="a843dabc66a52516f96612fa7c32631c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction from a compatible CloneOnWritePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. </p>

</div>
</div>
<a class="anchor" id="a8875d31f20908dd5cfcf86815349cede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::~<a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor decrements the reference count and deletes the object if the count goes to zero. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a90004b583b297d294caab778510a9837" title="Make this container empty, decrementing the use count of the contained object (if any)...">reset()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac1bce165ed3148676370306553fdaf08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment replaces the currently-held object by a deferred copy of the object held in the source container. </p>
<p>The copy will be created upon a subsequent write using the source object's <code>clone()</code> method. If the source container is empty this one will be empty after the assignment. Nothing happens if the source and destination were already managing the same object. </p>

</div>
</div>
<a class="anchor" id="aa1351ca22a5de6b5921b19add66481d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a compatible CloneOnWritePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. </p>

</div>
</div>
<a class="anchor" id="a19d08078e1b67df2966c43fcfc386b98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object's use count will be reduced by one and deleted if this was the last use. Nothing happens if the source and destination are the same containers. If they are different but are sharing the same object then the use count is reduced by one. </p>

</div>
</div>
<a class="anchor" id="aba55ea49da55d36f3442a61b3a566b47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment from a compatible CloneOnWritePtr. </p>
<p>Type U* must be implicitly convertible to type T*. </p>

</div>
</div>
<a class="anchor" id="a00da4ac5c738d5fb0c121482dae13558"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its <code>clone()</code> method. </p>
<p>The use count of the currently-held object (if any) is decremented and the object is deleted if this was the last reference to it. On return the use count of this container will be one. </p>

</div>
</div>
<a class="anchor" id="a8ad1aa921753aa38e5ff89f233cf58eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object. </p>
<p>The use count of the currently-held object is decremented and the object is deleted if this was the last reference to it. </p>

</div>
</div>
<a class="anchor" id="ac483710f060ce938840765a385b3a025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>No cloning is needed so this is very fast. Note that this is different than <code>get()</code> for the standard smart pointers which return a writable pointer. Use <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9a7ad53f09e64871aa0952932e312f6d" title="Clone if necessary to ensure the contained object is not shared, then return a writable pointer to th...">upd()</a> here for that purpose. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9a7ad53f09e64871aa0952932e312f6d" title="Clone if necessary to ensure the contained object is not shared, then return a writable pointer to th...">upd()</a>, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a3d26a596811ed59c1e3afbbc6fcc3fcf" title="Return a const reference to the contained object. ">getRef()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a7ad53f09e64871aa0952932e312f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::upd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone if necessary to ensure the contained object is not shared, then return a writable pointer to the contained (and now unshared) object if any, or <code>nullptr</code>. </p>
<p>If you only need read access, use <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac483710f060ce938840765a385b3a025" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> instead to avoid the potentially expensive cloning. Note that you need write access to this container in order to get write access to the object it contains. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac483710f060ce938840765a385b3a025" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a>, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a2cee60840bbcc2525721ebab5be64637" title="Clone if necessary to ensure the contained object is not shared, then return a writable reference to ...">updRef()</a>, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa1ee5e9f80299d50ce0774728f0c0e51" title="(Advanced) Force the contained object to be unique, that is, not shared with any other container...">detach()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d26a596811ed59c1e3afbbc6fcc3fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::getRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the contained object. </p>
<p>No cloning is needed so this is very fast. Don't call this if this container is empty. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac483710f060ce938840765a385b3a025" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2cee60840bbcc2525721ebab5be64637"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::updRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone if necessary to ensure the contained object is not shared, then return a writable reference to the contained (and now unshared) object. </p>
<p>Don't call this if this container is empty. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a9a7ad53f09e64871aa0952932e312f6d" title="Clone if necessary to ensure the contained object is not shared, then return a writable pointer to th...">upd()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee7e6bd1181466be2d004bdfb6c7e246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference a const pointer to the contained object. </p>
<p>This will fail if the container is empty. </p><dl class="section warning"><dt>Warning</dt><dd>This <code>const</code> operator will only be invoked if it is applied to a <code>const</code> container; otherwise the non-const method will be called and an unwanted copy may be performed. Use <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a3d26a596811ed59c1e3afbbc6fcc3fcf" title="Return a const reference to the contained object. ">getRef()</a> instead if you have a writable container but don't need write access to the contained object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7add7338b713f99632059eeebfa1ff8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone if necessary, then dereference a writable pointer to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a class="anchor" id="a0ade6648f901dd62cf1731bfc94d3e47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This "dereference" operator returns a const reference to the contained object. </p>
<p>This will fail if the container is empty. </p><dl class="section warning"><dt>Warning</dt><dd>This <code>const</code> method will only be invoked if it is applied to a <code>const</code> container; otherwise the non-const method will be called and an unwanted copy may be performed. Use <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a3d26a596811ed59c1e3afbbc6fcc3fcf" title="Return a const reference to the contained object. ">getRef()</a> instead if you have a writable container but don't need write access to the contained object. </dd></dl>

</div>
</div>
<a class="anchor" id="ade5029f0881198c4694a9323de29c89a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone if necessary, then return a writable reference to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a class="anchor" id="a90004b583b297d294caab778510a9837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this container empty, decrementing the use count of the contained object (if any), and deleting it if this was the last use. </p>
<p>The container is restored to its default-constructed state. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac706c1449db69f76c60f08ecc8dd4421" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae87ed731f397a14c523b6d14e493db9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the contents of this container with the supplied heap-allocated object, taking over ownership of that object and deleting the current one first if necessary. </p>
<p>Nothing happens if the supplied pointer is the same as the one already being managed. Otherwise, on return the use count will be one if the supplied pointer was non-null or else zero. </p>

</div>
</div>
<a class="anchor" id="a8a6d383f13455024e66f4785b4cfecd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this CloneOnWritePtr with another one, with ownership changing hands but no copying performed. </p>
<p>This is very fast; no heap activity occurs. Both containers must have been instantiated with the identical type. </p>

</div>
</div>
<a class="anchor" id="a4d15b6b1bdf7da8fe2c4e17bd2914412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return count of how many CloneOnWritePtr objects are currently sharing the referenced object. </p>
<p>There is never more than one holding an object for writing. If the pointer is null the use count is zero. </p>

</div>
</div>
<a class="anchor" id="a0b218ae4f68a0785fca9849a9fc12a9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the only user of the referenced object? Note that this means there is exactly one; if the managed pointer is null <code><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0b218ae4f68a0785fca9849a9fc12a9c" title="Is this the only user of the referenced object? Note that this means there is exactly one; if the man...">unique()</a></code> returns <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="ac706c1449db69f76c60f08ecc8dd4421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations. </p>

</div>
</div>
<a class="anchor" id="aec4e3c406a909af3d6f6bff28e80582d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a conversion to type bool that returns true if the container is non-null (that is, not empty). </p>

</div>
</div>
<a class="anchor" id="a630d53f9c80eb6bd7bf5680df5c5938b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Remove the contained object from management by this container and transfer ownership to the caller. </p>
<p>Clone if necessary to ensure that the contained object is not being shared with any other container, then extract the object from this container, leaving the container empty. A writable pointer to the object is returned. No object destruction occurs. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html#aa1ee5e9f80299d50ce0774728f0c0e51" title="(Advanced) Force the contained object to be unique, that is, not shared with any other container...">detach()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1ee5e9f80299d50ce0774728f0c0e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">SimTK::CloneOnWritePtr</a>&lt; T &gt;::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Force the contained object to be unique, that is, not shared with any other container. </p>
<p>(Normally this is done automatically when necessary; this method is like useful mostly for debugging.) If the referenced object is being shared (that is, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a4d15b6b1bdf7da8fe2c4e17bd2914412" title="Return count of how many CloneOnWritePtr objects are currently sharing the referenced object...">use_count()</a>&gt;1), clone it and replace the pointer with the newly cloned object. This CloneOnWritePtr will have a use count of zero or one after this call; other sharers of the object will see the shared use count reduced by one. If this is <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#ac706c1449db69f76c60f08ecc8dd4421" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> or <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a0b218ae4f68a0785fca9849a9fc12a9c" title="Is this the only user of the referenced object? Note that this means there is exactly one; if the man...">unique()</a> already then nothing happens. Note that you have to have write access to this container in order to detach it. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a1c09465396083cc53e0a51fa85f5595a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a305886fdde10d9f9d1eac1c13a912bda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1CloneOnWritePtr.html#a8a6d383f13455024e66f4785b4cfecd5" title="Swap the contents of this CloneOnWritePtr with another one, with ownership changing hands but no copy...">swap()</a> member of the <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> class. </p>
<p>(This function is defined in the <code><a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a></code> namespace.) </p>

</div>
</div>
<a class="anchor" id="ab4df0452a96b1da32bb197301e56dc25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class charT , class traits , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT, traits &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> object. </p>
<p>This is equivalent to <code>os &lt;&lt; p.get();</code>. </p>

</div>
</div>
<a class="anchor" id="abaa3df00bd1a5f653caded9d9cbfcc95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> containers. </p>
<p>Returns <code>true</code> if the pointers refer to the same object or if both are null. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a class="anchor" id="a805edb06386500e30487ee74383a68f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>. </p>

</div>
</div>
<a class="anchor" id="a66c84dc6d905d04e8e5fcd863e6ffd7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>. </p>

</div>
</div>
<a class="anchor" id="ab24aaa7eddbde21ecd90cd97c9e8231c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for two compatible <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to. </p>
<p>Returns <code>true</code> if the lhs pointer tests less than the rhs pointer. A null pointer tests less than any non-null pointer. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a class="anchor" id="aa6fe65c19e8cee630103f47f170122d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison against a <code>nullptr</code>. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method always returns <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="ab40af12397c373865361711db33958f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison of a <code>nullptr</code> against this container. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method returns <code>true</code> unless the container is empty. </p>

</div>
</div>
<a class="anchor" id="abe4250258c2521cad226082a51bd476c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer inequality test defined as <code>!(lhs==rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="a335f404de1522f46b8411885b29374da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>. </p>

</div>
</div>
<a class="anchor" id="aa9c31f81e65157147a6149eb64480acd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="aebc205fb339ea58d05d4edb95e2c4669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-than test defined as <code>rhs &lt; lhs</code>. </p>

</div>
</div>
<a class="anchor" id="af67e9a1b0fbac551dd20748babdd6e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>. </p>

</div>
</div>
<a class="anchor" id="a501845be0e9acafefb86dd8032abcc32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a49164d590f9c65ff017f111afd79cb70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="a4241a2a3e5d2e394e2ca88a4219dd806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>. </p>

</div>
</div>
<a class="anchor" id="a5e55858ff2ca40c0c1b2933144c8bd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="a8c47ba9794eefaced72b3427d6e04a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a class="anchor" id="a0e8bc6c2be1f4d9eed83037af1668a1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a class="anchor" id="a7e50ec408ab41fcb328562d729a7e8e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CloneOnWritePtr_8h_source.html">CloneOnWritePtr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1CloneOnWritePtr.html">CloneOnWritePtr</a></li>
    <li class="footer">Generated on Mon Apr 25 2016 16:28:46 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
